package lesson;

import java.util.Arrays;


public class Lesson16_2 {
	
	public static void task1() {
		// m - массив для исходных чисел (0 и 1)
		int[] m = new int[40];
		
		// Заполняем массив сгенерированными числами и тут же выводим их в строку
		// В языках принято, что имена счётчиков идут с i и далее: j, k, l...
		for( int i = 0 ; i < m.length ; i++ ) {
			m[i] = (int) (Math.random() * 2);
			System.out.print(m[i]);
		}
		
		// Переходим на новую строку после вывода сгенерированной последовательности
		System.out.print('\n');
		
		// В этом цикле мы определяем, сколько чисел потребуется, чтобы зашифровать нашу последовательность (count)
		boolean lookForZeros = true;
		int count = 1;
		for( int i = 0 ; i < m.length ; i++ ) {
			// Так как lookForZeros - логическая переменная, то она сама по себе уже является истинной или ложью
			// Инспектор намекает, что достаточно писать просто if( lookForZeros ) {}
			if (lookForZeros == true) {
				if (m[i] == 1 ) {
					lookForZeros = false;
					count++;
				}
			}
			else {
				if (m[i] == 0 ) {
					lookForZeros = true;
					count++;
				}
			}
		}
		
		// Мы посчитали необходимое количество чисел и объявляем массив для них
		int[] l = new int[count];
		
		// Снова пробегаем по исходному массиву, но теперь ищем подряд идущее количество цифр
		// Когда находим другую цифру, записываем это количество в массив
		lookForZeros = true;
		int index = 0;	// Индекс следующей ячейки массива, в которую мы запишем число
		int num = 0;	// Количество найденных подряд идущих 0 или 1
		for ( int i = 0 ; i < m.length ; i++ ) {
			if ( lookForZeros == true ) {
				if ( m[i] == 1 ) {
					lookForZeros = false;
					l[index] = num;
					num = 1;
					index++;
				}
				else {
					num++;
				}
			}
			else {
				if (m[i] == 0) {
					lookForZeros = true;
					l[index] = num;
					num = 1;
					index++;
				}
				// Форма записи без тела (фигурных скобок) возможна, если в теле выполняется всего 1 действие
				// Это позволяет экономить место в больших программах (нашу совсем нельзя назвать большой, но и в ней уже не так легко ориентироваться)
				else num++;
			}
		}
		
		// Предыдущий цикл записывает число только когда находит меняющуюся цифру, поэтому он дойдёт до конца и так и не запишет туда последнюю последовательность
		// Здесь мы делаем то, что не делает цикл
		l[index] = num;
		
		// Выводим результат через пробел (чтобы число 11 можно было отличить от идущих подряд 1 1)
		for (int i = 0; i < l.length; i++) {
			System.out.print(l[i] + " ");
		}
		// Готово
	}
	
	public static void task() {
		// В переменной n мы пишем число, до которого (включительно) мы ищем наши простые числа
		// Это даёт возможность изменять задание для программы одним действием
		int n = 120;
		
		// Объявляем массив логических чисел, каждое из которых соответствует рассматриваемому нами натуральному числу
		// Если элемент равен истине, то число простое
		boolean[] m;
		
		// Размер массива задан на 1 больше, чтобы индексы элементов соответствовали рассматриваемым натуральным числам
		// Массив размера 120+1 будет иметь индексы от 0 до 120, т.е. как раз покрывает исследуемый нами диапазон
		// 0 индекс мы никогда не используем
		m = new boolean[n + 1];
		
		// Данная функция заполняет наш массив значениями true. По-умолчанию мы предполагаем, что все числа - простые
		Arrays.fill( m, true );
		
		// Принцип работы самого алгоритма вы можете прочитать в интернете. Это было ваше домашнее задание
		for ( int i = 2 ; i < m.length ; i++ ) {
			// Данное условие в упрощённом виде звучит так:
			// Если элемент с индексом i истинен (т.е. простое число), а также если число i нечётное или равно двум, то...
			if ( m[i] && ( i % 2 == 1 || i == 2 ) ) {
				for ( int j = i * i ; j < m.length ; j = j + i ) {
					m[j] = false;
				}
			}
		}
		
		// Вывод простых чисел, т.е. тех, чьи элементы в конце работы алгоритма по-прежнему истина
		// Здесь мы используем тернарный оператор (есть в интернете). Выглядит он так:
		// [логическое_выражение] ? [значение_при_истине] : [значение_при_лжи]
		for ( int i = 2 ; i < m.length ; i++ ) {
			System.out.print( m[i] ? i + " " : "" );
			
			// Условие добавлено, чтобы блок ниже никогда не выполнялся и не дублировал вывод
			if( false ){
				
				// Этот тернарный оператор полностью эквивалентен следующей записи:
				if( m[i] ) {
					System.out.print( i + " " );
				}
				else {
					// "" - пустая строка. Технически, данная функция не выведет ничего, и, потому, ветка лжи может быть полностью убрана
					System.out.print( "" );
				}
			}
		}
	}
}